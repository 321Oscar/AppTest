/* generated by ASAP2 Studio 2.2.52.10934 */

ASAP2_VERSION 1 40
/begin PROJECT ProjectName ""

  /begin MODULE ModuleName ""

    /begin A2ML

        struct Protocol_Layer {
          uint;  /* XCP protocol layer version, current 0x100*/
          uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
          uint;  /* T2 [ms] Time-out of the checksum calculation*/
          uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
          uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
          uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
          uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
          uint;  /* T7 [ms] Time-out of the pre-action*/
          uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
          uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
          enum {
            "BYTE_ORDER_MSB_LAST" = 0,
            "BYTE_ORDER_MSB_FIRST" = 1
          };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
          enum {
            "ADDRESS_GRANULARITY_BYTE" = 1,
            "ADDRESS_GRANULARITY_WORD" = 2,
            "ADDRESS_GRANULARITY_DWORD" = 4
          };  /*The address granularity indicates the size of an element contained at a single address.*/
          taggedstruct {
            ("OPTIONAL_CMD" enum {
              "GET_COMM_MODE_INFO" = 251,
              "GET_ID" = 250,
              "SET_REQUEST" = 249,
              "GET_SEED" = 248,
              "UNLOCK" = 247,
              "SET_MTA" = 246,
              "UPLOAD" = 245,
              "SHORT_UPLOAD" = 244,
              "BUILD_CHECKSUM" = 243,
              "TRANSPORT_LAYER_CMD" = 242,
              "USER_CMD" = 241,
              "DOWNLOAD" = 240,
              "DOWNLOAD_NEXT" = 239,
              "DOWNLOAD_MAX" = 238,
              "SHORT_DOWNLOAD" = 237,
              "MODIFY_BITS" = 236,
              "SET_CAL_PAGE" = 235,
              "GET_CAL_PAGE" = 234,
              "GET_PAG_PROCESSOR_INFO" = 233,
              "GET_SEGMENT_INFO" = 232,
              "GET_PAGE_INFO" = 231,
              "SET_SEGMENT_MODE" = 230,
              "GET_SEGMENT_MODE" = 229,
              "COPY_CAL_PAGE" = 228,
              "CLEAR_DAQ_LIST" = 227,
              "SET_DAQ_PTR" = 226,
              "WRITE_DAQ" = 225,
              "SET_DAQ_LIST_MODE" = 224,
              "GET_DAQ_LIST_MODE" = 223,
              "START_STOP_DAQ_LIST" = 222,
              "START_STOP_SYNCH" = 221,
              "GET_DAQ_CLOCK" = 220,
              "READ_DAQ" = 219,
              "GET_DAQ_PROCESSOR_INFO" = 218,
              "GET_DAQ_RESOLUTION_INFO" = 217,
              "GET_DAQ_LIST_INFO" = 216,
              "GET_DAQ_EVENT_INFO" = 215,
              "FREE_DAQ" = 214,
              "ALLOC_DAQ" = 213,
              "ALLOC_ODT" = 212,
              "ALLOC_ODT_ENTRY" = 211,
              "PROGRAM_START" = 210,
              "PROGRAM_CLEAR" = 209,
              "PROGRAM" = 208,
              "PROGRAM_RESET" = 207,
              "GET_PGM_PROCESSOR_INFO" = 206,
              "GET_SECTOR_INFO" = 205,
              "PROGRAM_PREPARE" = 204,
              "PROGRAM_FORMAT" = 203,
              "PROGRAM_NEXT" = 202,
              "PROGRAM_MAX" = 201,
              "PROGRAM_VERIFY" = 200
            })*;  /* XCP-Code of optional command supported by the slave*/
            "COMMUNICATION_MODE_SUPPORTED" taggedunion {
              "BLOCK" taggedstruct {
                "SLAVE" ;
                "MASTER" struct {
                  uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                  uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                };
              };
              "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
            };
            "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
          };
        };

        struct Daq {
          enum {
            "STATIC" = 0,
            "DYNAMIC" = 1
          };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
          uint;  /* MAX_DAQ: Total number of available DAQ lists */
          uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
          uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
          enum {
            "OPTIMISATION_TYPE_DEFAULT" = 0,
            "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
            "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
            "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
            "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
            "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
          };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
          enum {
            "ADDRESS_EXTENSION_FREE" = 0,
            "ADDRESS_EXTENSION_ODT" = 1,
            "ADDRESS_EXTENSION_DAQ" = 3
          };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
          enum {
            "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
            "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
            "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
            "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
          };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
          enum {
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
            "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
          };  /* Granularity for size of ODT entry */
          uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
          enum {
            "NO_OVERLOAD_INDICATION" = 0,
            "OVERLOAD_INDICATION_PID" = 1,
            "OVERLOAD_INDICATION_EVENT" = 2
          };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
          taggedstruct {
            "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
            "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
            block "STIM" struct {
              enum {
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
              };  /* Granularity for size of ODT entry direction STIM*/
              uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
              taggedstruct {
                "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
              };
            };
            block "TIMESTAMP_SUPPORTED" struct {
              uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
              enum {
                "NO_TIME_STAMP" = 0,
                "SIZE_BYTE" = 1,
                "SIZE_WORD" = 2,
                "SIZE_DWORD" = 4
              };  /*Timestamp size in bytes*/
              enum {
                "UNIT_1NS" = 0,
                "UNIT_10NS" = 1,
                "UNIT_100NS" = 2,
                "UNIT_1US" = 3,
                "UNIT_10US" = 4,
                "UNIT_100US" = 5,
                "UNIT_1MS" = 6,
                "UNIT_10MS" = 7,
                "UNIT_100MS" = 8,
                "UNIT_1S" = 9
              };  /*Ticks per unit*/
              taggedstruct {
                "TIMESTAMP_FIXED" ;
              };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
            };
            "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
            (block "DAQ_LIST" struct {
              uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
              taggedstruct {
                "DAQ_LIST_TYPE" enum {
                  "DAQ" = 1,
                  "STIM" = 2,
                  "DAQ_STIM" = 3
                };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                block "PREDEFINED" taggedstruct {
                  (block "ODT" struct {
                    uchar;  /* ODT number */
                    taggedstruct {
                      ("ODT_ENTRY" struct {
                        uchar;  /* ODT_ENTRY number */
                        ulong;  /* address of element */
                        uchar;  /* address extension of element */
                        uchar;  /* size of element [AG] */
                        uchar;  /* BIT_OFFSET */
                      })*;
                    };
                  })*;
                };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
              };
            })*;
            (block "EVENT" struct {
              char[101];  /* EVENT_CHANNEL_NAME */
              char[9];  /* EVENT_CHANNEL_SHORT_NAME */
              uint;  /* EVENT_CHANNEL_NUMBER*/
              enum {
                "DAQ" = 1,
                "STIM" = 2,
                "DAQ_STIM" = 3
              };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
              uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
              uchar;  /* TIME_CYCLE: Event channel time cycle */
              uchar;  /* TIME_UNIT: Event channel time unit*/
              uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
            })*;
          };
        };

        taggedunion Daq_Event {
          "FIXED_EVENT_LIST" taggedstruct {
            ("EVENT" uint)*;
          };
          "VARIABLE" taggedstruct {
            block "AVAILABLE_EVENT_LIST" taggedstruct {
              ("EVENT" uint)*;
            };
            block "DEFAULT_EVENT_LIST" taggedstruct {
              ("EVENT" uint)*;
            };
          };
        };  /*This are characteristic for measurement objects*/

        struct Pag {
          uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
          taggedstruct {
            "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
          };
        };

        struct Pgm {
          enum {
            "PGM_MODE_ABSOLUTE" = 1,
            "PGM_MODE_FUNCTIONAL" = 2,
            "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
          };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
          uchar;  /* MAX_SECTORS: Total number of available sectors */
          uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
          taggedstruct {
            (block "SECTOR" struct {
              char[101];  /* SECTOR_NAME */
              uchar;  /* SECTOR_NUMBER*/
              ulong;  /* Start address for this SECTOR */
              ulong;  /* Length of this SECTOR [AG] */
              uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
              uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
              uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
            })*;
            "COMMUNICATION_MODE_SUPPORTED" taggedunion {
              "BLOCK" taggedstruct {
                "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                "MASTER" struct {
                  uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                  uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                };  /*This flag indicates whether the Master Block Mode is available */
              };
              "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
            };
          };
        };

        struct Segment {
          uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
          uchar;  /* Total number of available pages */
          uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
          uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
          uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
          taggedstruct {
            block "CHECKSUM" struct {
              enum {
                "XCP_ADD_11" = 1,
                "XCP_ADD_12" = 2,
                "XCP_ADD_14" = 3,
                "XCP_ADD_22" = 4,
                "XCP_ADD_24" = 5,
                "XCP_ADD_44" = 6,
                "XCP_CRC_16" = 7,
                "XCP_CRC_16_CITT" = 8,
                "XCP_CRC_32" = 9,
                "XCP_USER_DEFINED" = 255
              };  /* Checksum type*/
              taggedstruct {
                "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
              };
            };
            (block "PAGE" struct {
              uchar;  /* PAGE_NUMBER: Logical page number*/
              enum {
                "ECU_ACCESS_NOT_ALLOWED" = 0,
                "ECU_ACCESS_ALLOWED_WITHOUT_XCP_ONLY" = 1,
                "ECU_ACCESS_ALLOWED_WITH_XCP_ONLY" = 2,
                "ECU_ACCESS_ALLOWED_DONT_CARE" = 3
              };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
              enum {
                "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                "XCP_READ_ACCESS_ALLOWED_WITHOUT_ECU_ONLY" = 1,
                "XCP_READ_ACCESS_ALLOWED_WITH_ECU_ONLY" = 2,
                "XCP_READ_ACCESS_ALLOWED_DONT_CARE" = 3
              };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
              enum {
                "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                "XCP_WRITE_ACCESS_ALLOWED_WITHOUT_ECU_ONLY" = 1,
                "XCP_WRITE_ACCESS_ALLOWED_WITH_ECU_ONLY" = 2,
                "XCP_WRITE_ACCESS_ALLOWED_DONT_CARE" = 3
              };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
              taggedstruct {
                "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
              };
            })*;  /* PAGES for this SEGMENT */
            (block "ADDRESS_MAPPING" struct {
              ulong;  /* source address */
              ulong;  /* destination address */
              ulong;  /* length */
            })*;
            "PGM_VERIFY" ulong;  /* verification value for PGM */
          };
        };  /*Settings for MEMORY_SEGMENT */

        taggedstruct Common_Parameters {
          block "PROTOCOL_LAYER" struct Protocol_Layer;
          block "SEGMENT" struct Segment;
          block "DAQ" struct Daq;
          block "PAG" struct Pag;
          block "PGM" struct Pgm;
          block "DAQ_EVENT" taggedunion Daq_Event;
        };

        struct CAN_Parameters {
          uint;  /* XCP on CAN version, currentl 0x0100 */
          taggedstruct {
            "CAN_ID_BROADCAST" ulong;  /* Auto-detection CAN-ID */
            "CAN_ID_MASTER" ulong;  /* CMD/STIM CAN-ID */
            "CAN_ID_SLAVE" ulong;  /* RES/ERR/EV/SERV/DAQ CAN-ID */
            "BAUDRATE" ulong;  /* Baudrate in Hz */
            "SAMPLE_POINT" uchar;  /* Sample point in % of bit time */
            "SAMPLE_RATE" enum {
              "SINGLE" = 1,
              "TRIPLE" = 3
            };  /* Sample per bit */
            "BTL_CYCLES" uchar;  /* slots per bit time */
            "SJW" uchar;  /*Length synchr. segment */
            "SYNC_EDGE" enum {
              "SINGLE" = 1,
              "DUAL" = 2
            };  /* SINGLE: on falling edge only
 DUAL: on falling and rising edge*/
            "MAX_DLC_REQUIRED" ;  /* master to slave frames always to have DLC = MAX_DLC = 8*/
            (block "DAQ_LIST_CAN_ID" struct {
              uint;  /* reference to DAQ_LIST_NUMBER */
              taggedstruct {
                "VARIABLE" ;
                "FIXED" ulong;  /* this DAQ_LIST always on this CAN_ID */
              };  /* exclusive tags: either VARIABLE or FIXED */
            })*;
          };
        };

        struct SxI_Parameters {
          uint;  /* XCP on SxI version, currently 0x0100 */
          ulong;  /* BAUDRATE [Hz] */
          taggedstruct {
            "ASYNCH_FULL_DUPLEX_MODE" struct {
              enum {
                "PARITY_NONE" = 0,
                "PARITY_ODD" = 1,
                "PARITY_EVEN" = 2
              };  /* Parity bit settings*/
              enum {
                "ONE_STOP_BIT" = 1,
                "TWO_STOP_BITS" = 2
              };  /*Stop bit settings*/
            };
            "SYNCH_FULL_DUPLEX_MODE_BYTE" ;
            "SYNCH_FULL_DUPLEX_MODE_WORD" ;
            "SYNCH_FULL_DUPLEX_MODE_DWORD" ;
            "SYNCH_MASTER_SLAVE_MODE_BYTE" ;
            "SYNCH_MASTER_SLAVE_MODE_WORD" ;
            "SYNCH_MASTER_SLAVE_MODE_DWORD" ;
          };  /* exclusive tags */
          enum {
            "HEADER_LEN_BYTE" = 0,
            "HEADER_LEN_CTR_BYTE" = 1,
            "HEADER_LEN_WORD" = 2,
            "HEADER_LEN_CTR_WORD" = 3
          };  /* XCP packet header */
          enum {
            "NO_CHECKSUM" = 0,
            "CHECKSUM_BYTE" = 1,
            "CHECKSUM_WORD" = 2
          };  /* Checksum type*/
        };

        struct TCP_IP_Parameters {
          uint;  /* XCP on TCP_IP version, currently 0x0100 */
          uint;  /* PORT */
          taggedunion {
            "HOST_NAME" char[256];  /*Name of the host like localhost*/
            "ADDRESS" char[15];  /* IP address like 127.0.0.1*/
          };
        };

        struct UDP_IP_Parameters {
          uint;  /* XCP on UDP version, currently 0x0100 */
          uint;  /* PORT */
          taggedunion {
            "HOST_NAME" char[256];  /*Name of the host like localhost*/
            "ADDRESS" char[15];  /* IP address like 127.0.0.1*/
          };
        };

        struct ep_parameters {
          uchar;  /* ENDPOINT_NUMBER, not endpoint address */
          enum {
            "BULK_TRANSFER" = 2,
            "INTERRUPT_TRANSFER" = 3
          };
          uint;  /* wMaxPacketSize: Maximum packet  
 size of endpoint in bytes       */
          uchar;  /* bInterval: polling of endpoint  */
          enum {
            "MESSAGE_PACKING_SINGLE" = 0,
            "MESSAGE_PACKING_MULTIPLE" = 1,
            "MESSAGE_PACKING_STREAMING" = 2
          };  /* Packing of XCP Messages         
 SINGLE: Single per USB data packet    
 MULTIPLE: Multiple per USB data packet  
 STREAMING: No restriction by packet sizes*/
          enum {
            "ALIGNMENT_8_BIT" = 0,
            "ALIGNMENT_16_BIT" = 1,
            "ALIGNMENT_32_BIT" = 2,
            "ALIGNMENT_64_BIT" = 3
          };  /* Alignment mandatory for all packing types*/
          taggedstruct {
            "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host 
 buffer size. The size is defined
 as multiple of wMaxPacketSize.  */
          };
        };

        struct USB_Parameters {
          uint;  /* XCP on USB version  
 e.g. "1.0" = 0x0100 */
          uint;  /* Vendor ID                       */
          uint;  /* Product ID                      */
          uchar;  /* Number of interface             */
          enum {
            "HEADER_LEN_BYTE" = 0,
            "HEADER_LEN_CTR_BYTE" = 1,
            "HEADER_LEN_FILL_BYTE" = 2,
            "HEADER_LEN_WORD" = 3,
            "HEADER_LEN_CTR_WORD" = 4,
            "HEADER_LEN_FILL_WORD" = 5
          };  /* XCP packet header */
          taggedunion {
            block "OUT_EP_CMD_STIM" struct ep_parameters;  /* OUT-EP for CMD and STIM (if not specified otherwise)*/
          };
          taggedunion {
            block "IN_EP_RESERR_DAQ_EVSERV" struct ep_parameters;  /* IN-EP for RES/ERR, 
 DAQ (if not specified otherwise) and  
 EV/SERV (if not specified otherwise)  */
          };
          taggedstruct {
            "ALTERNATE_SETTING_NO" uchar;  /* Number of alternate setting   */
            "INTERFACE_STRING_DESCRIPTOR" char[101];  /* String Descriptor of XCP interface*/
            (block "OUT_EP_ONLY_STIM" struct ep_parameters)*;  /* multiple OUT-EP's for STIM */
            (block "IN_EP_ONLY_DAQ" struct ep_parameters)*;  /* multiple IN-EP's for DAQ*/
            block "IN_EP_ONLY_EVSERV" struct ep_parameters;  /* only one IN-EP for EV/SERV*/
            (block "DAQ_LIST_USB_ENDPOINT" struct {
              uint;  /* reference to DAQ_LIST_NUMBER          */
              taggedstruct {
                "FIXED_IN" uchar;  /* this DAQ list always                
 ENDPOINT_NUMBER, not endpoint address */
                "FIXED_OUT" uchar;  /* this STIM list always               
 ENDPOINT_NUMBER, not endpoint address */
              };
            })*;
          };
        };

        enum packet_assignment_type {
          "NOT_ALLOWED" = 0,
          "FIXED" = 1,
          "VARIABLE_INITIALISED" = 2,
          "VARIABLE" = 3
        };

        struct buffer {
          uchar;  /* Buffer number*/
          taggedstruct {
            "MAX_FLX_LEN_BUF" taggedunion {
              "FIXED" uchar;  /* constant value, can't be modified on runtime */
              "VARIABLE" uchar;  /* initial value, can be modified on runtime*/
            };  /* maximal size of the buffer [byte]*/
            block "LPDU_ID" taggedstruct {
              "FLX_SLOT_ID" taggedunion {
                "FIXED" uint;  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" uint;
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay timing, slot id*/
              "OFFSET" taggedunion {
                "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" uchar;
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay timing, base cycle*/
              "CYCLE_REPETITION" taggedunion {
                "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" uchar;
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay timing, cycle repetition*/
              "CHANNEL" taggedunion {
                "FIXED" enum {
                  "A" = 0,
                  "B" = 1
                };  /* constant value, can't be modified on runtime*/
                "VARIABLE" taggedstruct {
                  "INITIAL_VALUE" enum {
                    "A" = 0,
                    "B" = 1
                  };
                };  /* initial value, can be modified on runtime*/
              };  /* FlexRay Channel A or B*/
            };  /* LPDU-ID,  Data  Link  Layer  Protocol  Data  Unit  Identifier*/
            block "XCP_PACKET" taggedstruct {
              "CMD" enum packet_assignment_type;
              "RES_ERR" enum packet_assignment_type;
              "EV_SERV" enum packet_assignment_type;
              "DAQ" enum packet_assignment_type;
              "STIM" enum packet_assignment_type;
            };  /* XCP packet type*/
          };
        };

        struct FLX_Parameters {
          uint;  /* XCP on FlexRay version
 e.g. "1.0" = 0x0100*/
          uint;  /* T1_FLX [ms] Time-out while waiting for an XCP on FlexRay response
 e.g. FLX_ASSIGN*/
          char[256];  /* FIBEX-file with extension and without path, including CHI information*/
          char[256];  /* cluster-ID, id attribute of the FIBEX cluster*/
          uchar;  /* NAX, node address of the ECU*/
          enum {
            "HEADER_NAX" = 0,
            "HEADER_NAX_FILL" = 1,
            "HEADER_NAX_CTR" = 2,
            "HEADER_NAX_FILL3" = 3,
            "HEADER_NAX_CTR_FILL2" = 4,
            "HEADER_NAX_LEN" = 5,
            "HEADER_NAX_CTR_LEN" = 6,
            "HEADER_NAX_FILL2_LEN" = 7,
            "HEADER_NAX_CTR_FILL_LEN" = 8
          };  /* header type of the XCP on FlexRay message*/
          enum {
            "PACKET_ALIGNMENT_8" = 0,
            "PACKET_ALIGNMENT_16" = 1,
            "PACKET_ALIGNMENT_32" = 2
          };  /* XCP packet alignment within the XCP on FlexRay Message*/
          taggedunion {
            block "INITIAL_CMD_BUFFER" struct buffer;
          };  /* XCP dedicated buffer used to transmit XCP commands*/
          taggedunion {
            block "INITIAL_RES_ERR_BUFFER" struct buffer;
          };  /* XCP dedicated buffer used to receive the responses on the XCP commands*/
          taggedstruct {
            (block "POOL_BUFFER" struct buffer)*;
          };  /* XCP dedicated buffer(s) used for XCP-DAQ, -STIM and -EV/SERV*/
        };
      block "IF_DATA" taggedunion {
        "XCP" struct {
          taggedstruct Common_Parameters;  /* default parameters */
          taggedstruct {
            block "XCP_ON_CAN" struct {
              struct CAN_Parameters;  /* specific for CAN */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_SxI" struct {
              struct SxI_Parameters;  /* specific for SxI */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_TCP_IP" struct {
              struct TCP_IP_Parameters;  /* specific for TCP_IP */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_UDP_IP" struct {
              struct UDP_IP_Parameters;  /* specific for UDP_IP   */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_USB" struct {
              struct USB_Parameters;  /* specific for USB      */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
            block "XCP_ON_FLX" struct {
              struct FLX_Parameters;  /* specific for FlexRay  */
              taggedstruct Common_Parameters;  /* overruling of default */
            };
          };  /* transport layer parameters*/
        };
      };
    /end A2ML

    /begin MOD_PAR ""
    /end MOD_PAR

    /begin MOD_COMMON ""
      BYTE_ORDER MSB_FIRST
      ALIGNMENT_BYTE 1
      ALIGNMENT_WORD 2
      ALIGNMENT_LONG 4
      ALIGNMENT_FLOAT32_IEEE 4
      ALIGNMENT_FLOAT64_IEEE 8
    /end MOD_COMMON

    /begin IF_DATA XCP
      /begin PROTOCOL_LAYER
        0x0100
        0x07D0
        0x2710
        0x00
        0x00
        0x00
        0x00
        0x00
        0x08
        0x08
        BYTE_ORDER_MSB_FIRST
        ADDRESS_GRANULARITY_BYTE
        OPTIONAL_CMD ALLOC_ODT_ENTRY
        OPTIONAL_CMD ALLOC_ODT
        OPTIONAL_CMD ALLOC_DAQ
        OPTIONAL_CMD FREE_DAQ
        OPTIONAL_CMD GET_DAQ_EVENT_INFO
        OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
        OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
        OPTIONAL_CMD GET_DAQ_CLOCK
        OPTIONAL_CMD START_STOP_SYNCH
        OPTIONAL_CMD START_STOP_DAQ_LIST
        OPTIONAL_CMD GET_DAQ_LIST_MODE
        OPTIONAL_CMD SET_DAQ_LIST_MODE
        OPTIONAL_CMD WRITE_DAQ
        OPTIONAL_CMD SET_DAQ_PTR
        OPTIONAL_CMD CLEAR_DAQ_LIST
        OPTIONAL_CMD DOWNLOAD
        OPTIONAL_CMD SHORT_UPLOAD
        OPTIONAL_CMD UPLOAD
        OPTIONAL_CMD SET_MTA
        COMMUNICATION_MODE_SUPPORTED BLOCK
          SLAVE
      /end PROTOCOL_LAYER
      /begin DAQ
        DYNAMIC
        0x00
        0x02
        0x00
        OPTIMISATION_TYPE_DEFAULT
        ADDRESS_EXTENSION_FREE
        IDENTIFICATION_FIELD_TYPE_ABSOLUTE
        GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
        0xFF
        NO_OVERLOAD_INDICATION
        PRESCALER_SUPPORTED
        /begin TIMESTAMP_SUPPORTED
          0x01
          SIZE_WORD
          UNIT_1MS
        /end TIMESTAMP_SUPPORTED
        /begin EVENT
          "10msRstr"
          "10msRstr"
          0x00
          DAQ
          0x01
          0x0A
          0x06
          0x02
        /end EVENT
        /begin EVENT
          "100msRstr"
          "100msRstr"
          0x01
          DAQ
          0x01
          0x0A
          0x07
          0x01
        /end EVENT
      /end DAQ
      /begin PAG
        0x00
      /end PAG
      /begin PGM
        PGM_MODE_ABSOLUTE
        0x00
        0x00
      /end PGM
      /begin XCP_ON_CAN
        0x0100
        CAN_ID_MASTER 0x07AA
        CAN_ID_SLAVE 0x07AB
        BAUDRATE 0x07A120
        SAMPLE_POINT 0x4B
        SAMPLE_RATE SINGLE
        BTL_CYCLES 0x08
        SJW 0x02
        SYNC_EDGE SINGLE
      /end XCP_ON_CAN
    /end IF_DATA

    /begin MEASUREMENT ASW_Core0_1000ms_cnt ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
      ECU_ADDRESS 0x52802A5C
    /end MEASUREMENT

    /begin MEASUREMENT ASW_Core0_100ms_cnt ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
      ECU_ADDRESS 0x52802A8C
    /end MEASUREMENT

    /begin MEASUREMENT ASW_Core0_10ms_cnt ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
      ECU_ADDRESS 0x52802AC0
    /end MEASUREMENT

    /begin MEASUREMENT ASW_Core0_1ms_cnt ""
      ULONG NO_COMPU_METHOD 0 0 0 4294967295
      ECU_ADDRESS 0x52802AF8
    /end MEASUREMENT

    /begin MEASUREMENT AdcRealVal.V_DC ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52803B38
    /end MEASUREMENT

    /begin CHARACTERISTIC Cal_CurntCtrl_Ki_d ""
      VALUE 0x528005D8 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC Cal_CurntCtrl_Ki_q ""
      VALUE 0x528005D0 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC Cal_CurntCtrl_Kp_d ""
      VALUE 0x528005DC __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC Cal_CurntCtrl_Kp_q ""
      VALUE 0x528005D4 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC Cal_RslvOfst ""
      VALUE 0x5280057C __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin MEASUREMENT CurntCtrl.Id_Fb ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528027C0
    /end MEASUREMENT

    /begin MEASUREMENT CurntCtrl.Id_Ref ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528027B8
    /end MEASUREMENT

    /begin MEASUREMENT CurntCtrl.Iq_Fb ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528027C4
    /end MEASUREMENT

    /begin MEASUREMENT CurntCtrl.Iq_Ref ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528027BC
    /end MEASUREMENT

    /begin MEASUREMENT CurntCtrl.UdFb ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x5280285C
    /end MEASUREMENT

    /begin MEASUREMENT CurntCtrl.UqFb ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52802858
    /end MEASUREMENT

    /begin MEASUREMENT CurntCtrl.UsOutFlt ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52802854
    /end MEASUREMENT

    /begin CHARACTERISTIC DebugCAN.CtrlMode ""
      VALUE 0x528010DD __UByte_Value 0 NO_COMPU_METHOD 0 255
    /end CHARACTERISTIC

    /begin CHARACTERISTIC DebugCAN.Enable ""
      VALUE 0x528010DC __UByte_Value 0 NO_COMPU_METHOD 0 255
    /end CHARACTERISTIC

    /begin CHARACTERISTIC DebugCAN.IsCMD ""
      VALUE 0x528010D4 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC DebugCAN.ThetaCMD ""
      VALUE 0x528010D8 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin MEASUREMENT ErrorCheck.Out_U8_12VLowerWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280216F
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_12VOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280216C
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_5VLowerWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802171
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_5VOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802170
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_BlockFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A0
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_BlockWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802177
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can0B6LostMsgFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802136
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can0B6TimeOutFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280214B
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can100InvalidFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802144
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can100LostMsgFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802135
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can100TimeOutFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280214C
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can1BusOffFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280214F
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_Can2BusOffFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280214E
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CoolerTempOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802173
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CoolerTempSenorFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802174
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CrashFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A1
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CurrSenFaultAll ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528020EC
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CurrSenUPhFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528020ED
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CurrSenVPhFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802179
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_CurrSenWPhFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802178
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_DrvPBCCurrLowWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280215D
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_DrvPBCCurrOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280215C
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWCurrPHOverFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802131
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWDeadFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802132
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWFoBFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802134
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWFoTFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802133
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWRdcFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528020C0
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWVoltLowerFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280212F
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_HWVoltOverFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802130
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_IgbtEstimTempOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802110
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_IgbtTemSenFaultAll ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A7
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_IgbtTempOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802175
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_McuTempOverFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280215E
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_MotTemSenWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802199
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_MotTemSenWarnAll ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802198
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_OPFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802108
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_SpdOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802176
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VcuSpdCmdWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280212E
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VcuTroqCmdWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802138
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VextsLowerWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280216D
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VextsOverWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280216E
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VoltLowerWarn ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A3
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VoltOverFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A4
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VoltSuperLower ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A2
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_U8_VoltSuperOverFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x528021A5
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_0NMFlag ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280211C
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_ASCTFlag ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280211A
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_DisIGBTFlag ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802119
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_ErrLevel ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802118
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_LimSpeedTorFlag ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280211E
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_LimTorFlag ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5280211D
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_MotorTempWarnBeginLimit ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802101
    /end MEASUREMENT

    /begin MEASUREMENT ErrorCheck.Out_UT8_MultiOverCurrentFault ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52802100
    /end MEASUREMENT

    /begin CHARACTERISTIC EventFrame.Switcher ""
      VALUE 0x528010D2 __UByte_Value 0 NO_COMPU_METHOD 0 255
    /end CHARACTERISTIC

    /begin MEASUREMENT MtrCalib.IdSet ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528110CC
    /end MEASUREMENT

    /begin MEASUREMENT MtrCalib.IqSet ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528110D0
    /end MEASUREMENT

    /begin MEASUREMENT MtrCalib.ThtSetReal ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x528110E0
    /end MEASUREMENT

    /begin MEASUREMENT StateMachineStruct.Out_U16_State ""
      UWORD NO_COMPU_METHOD 0 0 0 65535
      ECU_ADDRESS 0x52802678
    /end MEASUREMENT

    /begin CHARACTERISTIC TestID_Struct.Test_ID_7AF_Spdloop_Towing_Platform ""
      VALUE 0x52801112 __UByte_Value 0 NO_COMPU_METHOD 0 255
    /end CHARACTERISTIC

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_0CB_RollingCounter ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52801A66
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_120_RollingCounter ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52801A6B
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_ActualTorqueFB ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A58
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_DrvMotorInletTemp "WaterTemp"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A78
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_DrvMotorRPM ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A50
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_DrvMotorTemp "MotorTempMax"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A8C
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_DrvMotorWorkSts ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x52801A5F
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_MainWireVolt ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A88
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_MaxTorqueAllow ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A70
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_Temp "IgbtTempMax"
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A7C
    /end MEASUREMENT

    /begin MEASUREMENT UserCAN0_TxMSG.RMCU_Us_Out ""
      FLOAT32_IEEE NO_COMPU_METHOD 0 0 -3.40282346639E+38 3.40282346639E+38
      ECU_ADDRESS 0x52801A98
    /end MEASUREMENT

    /begin CHARACTERISTIC VCU_Msg.VCU_RDrvControlMode ""
      VALUE 0x52801A08 __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
    /end CHARACTERISTIC

    /begin CHARACTERISTIC VCU_Msg.VCU_RDrvRequesSpeed ""
      VALUE 0x52801A0C __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC VCU_Msg.VCU_RDrvRequestTorque ""
      VALUE 0x52801A04 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC VCU_Msg.VCU_VehicleSts ""
      VALUE 0x52801A1C __ULong_Value 0 NO_COMPU_METHOD 0 4294967295
    /end CHARACTERISTIC

    /begin CHARACTERISTIC VCU_SpdloopTorLimitDn ""
      VALUE 0x52800E50 __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC VCU_SpdloopTorLimitUp ""
      VALUE 0x52800E4C __Float32_Value 0 NO_COMPU_METHOD -3.40282346639E+38 3.40282346639E+38
    /end CHARACTERISTIC

    /begin CHARACTERISTIC XCP_Calib_EnFlag ""
      VALUE 0x52800E5A __UByte_Value 0 NO_COMPU_METHOD 0 255
    /end CHARACTERISTIC

    /begin CHARACTERISTIC XCP_VCU_EnFlag ""
      VALUE 0x52800E59 __UByte_Value 0 NO_COMPU_METHOD 0 255
    /end CHARACTERISTIC

    /begin RECORD_LAYOUT __Float32_Value
      FNC_VALUES 1 FLOAT32_IEEE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT __UByte_Value
      FNC_VALUES 1 UBYTE ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT __ULong_Value
      FNC_VALUES 1 ULONG ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin RECORD_LAYOUT __UWord_Value
      FNC_VALUES 1 UWORD ROW_DIR DIRECT
    /end RECORD_LAYOUT

    /begin GROUP Calibration ""
      /begin REF_CHARACTERISTIC
        Cal_CurntCtrl_Ki_d Cal_CurntCtrl_Ki_q Cal_CurntCtrl_Kp_d Cal_CurntCtrl_Kp_q Cal_RslvOfst DebugCAN.CtrlMode DebugCAN.Enable
        DebugCAN.IsCMD DebugCAN.ThetaCMD
      /end REF_CHARACTERISTIC
    /end GROUP

    /begin GROUP MCUFaults ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_UT8_0NMFlag ErrorCheck.Out_UT8_ASCTFlag ErrorCheck.Out_UT8_DisIGBTFlag ErrorCheck.Out_UT8_ErrLevel ErrorCheck.Out_UT8_LimSpeedTorFlag ErrorCheck.Out_UT8_LimTorFlag
      /end REF_MEASUREMENT
      /begin SUB_GROUP
        MoF_COM MoF_MCS MoF_MotVoltsNCurr MoF_MotorStatus MoF_Other MoF_PCB MoF_Temperature
      /end SUB_GROUP
    /end GROUP

    /begin GROUP MCUstatus ""
      /begin SUB_GROUP
        MoSta_IdIq_Ctrl MoSta_Status MoSta_Temperature
      /end SUB_GROUP
    /end GROUP

    /begin GROUP MoF_COM ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_Can0B6LostMsgFault ErrorCheck.Out_U8_Can0B6TimeOutFault ErrorCheck.Out_U8_Can100InvalidFault ErrorCheck.Out_U8_Can100LostMsgFault ErrorCheck.Out_U8_Can100TimeOutFault ErrorCheck.Out_U8_Can1BusOffFault ErrorCheck.Out_U8_Can2BusOffFault
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoF_MCS ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_HWCurrPHOverFault ErrorCheck.Out_U8_HWDeadFault ErrorCheck.Out_U8_HWFoBFault ErrorCheck.Out_U8_HWFoTFault ErrorCheck.Out_U8_HWVoltLowerFault ErrorCheck.Out_U8_HWVoltOverFault
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoF_MotVoltsNCurr ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_CurrSenFaultAll ErrorCheck.Out_U8_CurrSenUPhFault ErrorCheck.Out_U8_CurrSenVPhFault ErrorCheck.Out_U8_CurrSenWPhFault ErrorCheck.Out_U8_SpdOverWarn ErrorCheck.Out_U8_VoltLowerWarn ErrorCheck.Out_U8_VoltOverFault
        ErrorCheck.Out_U8_VoltSuperLower ErrorCheck.Out_U8_VoltSuperOverFault ErrorCheck.Out_UT8_MultiOverCurrentFault
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoF_MotorStatus ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_BlockFault ErrorCheck.Out_U8_BlockWarn ErrorCheck.Out_U8_CrashFault ErrorCheck.Out_U8_VcuSpdCmdWarn ErrorCheck.Out_U8_VcuTroqCmdWarn ErrorCheck.Out_UT8_MotorTempWarnBeginLimit
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoF_Other ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_HWRdcFault ErrorCheck.Out_U8_OPFault
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoF_PCB ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_12VLowerWarn ErrorCheck.Out_U8_12VOverWarn ErrorCheck.Out_U8_5VLowerWarn ErrorCheck.Out_U8_5VOverWarn ErrorCheck.Out_U8_DrvPBCCurrLowWarn ErrorCheck.Out_U8_DrvPBCCurrOverWarn ErrorCheck.Out_U8_VextsLowerWarn
        ErrorCheck.Out_U8_VextsOverWarn
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoF_Temperature ""
      /begin REF_MEASUREMENT
        ErrorCheck.Out_U8_CoolerTempOverWarn ErrorCheck.Out_U8_CoolerTempSenorFault ErrorCheck.Out_U8_IgbtEstimTempOverWarn ErrorCheck.Out_U8_IgbtTemSenFaultAll ErrorCheck.Out_U8_IgbtTempOverWarn ErrorCheck.Out_U8_McuTempOverFault ErrorCheck.Out_U8_MotTemSenWarn
        ErrorCheck.Out_U8_MotTemSenWarnAll
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoSta_IdIq_Ctrl ""
      /begin REF_MEASUREMENT
        AdcRealVal.V_DC CurntCtrl.Id_Fb CurntCtrl.Id_Ref CurntCtrl.Iq_Fb CurntCtrl.Iq_Ref CurntCtrl.UdFb CurntCtrl.UqFb
        CurntCtrl.UsOutFlt MtrCalib.IdSet MtrCalib.IqSet MtrCalib.ThtSetReal UserCAN0_TxMSG.RMCU_Us_Out
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoSta_Status ""
      /begin REF_MEASUREMENT
        StateMachineStruct.Out_U16_State UserCAN0_TxMSG.RMCU_ActualTorqueFB UserCAN0_TxMSG.RMCU_DrvMotorRPM UserCAN0_TxMSG.RMCU_DrvMotorWorkSts UserCAN0_TxMSG.RMCU_MainWireVolt UserCAN0_TxMSG.RMCU_MaxTorqueAllow
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP MoSta_Temperature ""
      /begin REF_MEASUREMENT
        UserCAN0_TxMSG.RMCU_DrvMotorInletTemp UserCAN0_TxMSG.RMCU_DrvMotorTemp UserCAN0_TxMSG.RMCU_Temp
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP Test ""
      /begin REF_CHARACTERISTIC
        EventFrame.Switcher
      /end REF_CHARACTERISTIC
      /begin REF_MEASUREMENT
        ASW_Core0_1000ms_cnt ASW_Core0_100ms_cnt ASW_Core0_10ms_cnt ASW_Core0_1ms_cnt UserCAN0_TxMSG.RMCU_0CB_RollingCounter UserCAN0_TxMSG.RMCU_120_RollingCounter
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP VCU ""
      /begin REF_CHARACTERISTIC
        TestID_Struct.Test_ID_7AF_Spdloop_Towing_Platform VCU_Msg.VCU_RDrvControlMode VCU_Msg.VCU_RDrvRequesSpeed VCU_Msg.VCU_RDrvRequestTorque VCU_Msg.VCU_VehicleSts VCU_SpdloopTorLimitDn VCU_SpdloopTorLimitUp
      /end REF_CHARACTERISTIC
    /end GROUP

  /end MODULE

/end PROJECT
